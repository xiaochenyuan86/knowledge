每一条语句需要加上`;` 才可以正确执行

执行脚本时，不需要加







# MySQL使用B+树作为索引

MySQL 是会将数据持久化在硬盘，而存储功能是由 MySQL 存储引擎实现的，所以讨论 MySQL 使用哪种数据结构作为索引，实际上是在讨论存储引擎使用哪种数据结构作为索引，InnoDB 是 MySQL 默认的存储引擎，它就是采用了 B+ 树作为索引的数据结构。

要设计一个 MySQL 的索引数据结构，不仅仅考虑数据结构增删改的时间复杂度，更重要的是要考虑磁盘 I/O 的操作次数。因为索引和记录都是存放在硬盘，硬盘是一个非常慢的存储设备，我们在查询数据的时候，最好能在尽可能少的磁盘 I/O 的操作次数内完成。

二分查找树虽然是一个天然的二分结构，能很好的利用二分查找快速定位数据，但是它存在一种极端的情况，每当插入的元素都是树内最大的元素，就会导致二分查找树退化成一个链表，此时查询复杂度就会从 O(logn)降低为 O(n)。

为了解决二分查找树退化成链表的问题，就出现了自平衡二叉树，保证了查询操作的时间复杂度就会一直维持在 O(logn) 。但是它本质上还是一个二叉树，每个节点只能有 2 个子节点，随着元素的增多，树的高度会越来越高。

而树的高度决定于磁盘  I/O 操作的次数，因为树是存储在磁盘中的，访问每个节点，都对应一次磁盘 I/O 操作，也就是说树的高度就等于每次查询数据时磁盘 IO 操作的次数，所以树的高度越高，就会影响查询性能。

B 树和 B+ 都是通过多叉树的方式，会将树的高度变矮，所以这两个数据结构非常适合检索存于磁盘中的数据。

MySQL 默认的存储引擎 InnoDB **采用的是 B+ 作为索引的数据结构，原因有：**

- B+ 树的非叶子节点不存放实际的记录数据，仅存放索引，因此数据量相同的情况下，相比存储即存索引又存记录的 B 树，**B+树的非叶子节点可以存放更多的索引，因此 B+ 树可以比 B 树更「矮胖」，查询底层节点的磁盘 I/O次数会更少。**
- B+ 树**有大量的冗余节点**（所有非叶子节点都是冗余索引），这些冗余索引让 B+ 树在**插入、删除的效率都更高**，比如删除根节点的时候，不会像 B 树那样会发生复杂的树的变化；
- B+ 树**叶子节点之间用链表连接了起来**，有利于**范围查询**，而 B 树要实现范围查询，因此只能通过树的遍历来完成范围查询，这会涉及多个节点的磁盘 I/O 操作，范围查询效率不如 B+ 树。

https://mp.weixin.qq.com/s/w1ZFOug8-Sa7ThtMnlaUtQ



每访问一个树的节点，都需要一次磁盘IO

树越“矮胖”，磁盘IO越少



B+Tree 存储千万级的数据只需要 3-4 层高度就可以满足，这意味着从千万级的表查询目标数据最多需要 3-4 次磁盘 I/O，所以**B+Tree 相比于 B 树和二叉树来说，最大的优势在于查询效率很高，因为即使在数据量很大的情况，查询一个数据的磁盘 I/O 依然维持在 3-4次。**





# 什么是视图

视图（View）是在关系型数据库中的一个虚拟表，它是根据一个或多个基本表（或其他视图）的查询结果生成的结果集，可以像表一样进行查询，但实际上并不存储任何数据。视图提供了一种抽象层，允许用户通过简化的方式访问或修改底层数据表的内容，同时还可以用于控制对数据的访问权限。

以下是关于视图的一些重要概念和用途：

1. **虚拟表格**：视图不包含实际的数据，它只包含一个查询的定义。当您查询视图时，实际上是执行了视图查询的结果，而不是查询基础表。

2. **数据抽象**：视图允许数据库管理员或应用程序开发人员隐藏底层表的复杂性和细节，使用户可以以更简单、更易理解的方式访问数据。

3. **安全性**：通过视图，您可以限制用户对数据的访问权限。这可以用于实现基于角色或权限的数据安全性，确保只有授权用户能够访问特定的数据。

4. **查询重用**：您可以创建视图来存储常用的查询，以便多次重复使用，而不必每次都重新编写复杂的查询语句。

5. **数据转换和格式化**：视图允许您在不修改底层数据的情况下对数据进行格式化和转换，以满足特定的应用需求。

6. **联接表**：视图还可以用于简化多个表之间的关联查询，使复杂的查询变得更容易管理和维护。

创建视图的语法通常如下：

```sql
CREATE VIEW view_name AS
SELECT column1, column2, ...
FROM table_name
WHERE condition;
```

其中：
- `view_name` 是视图的名称。
- `SELECT` 子句定义了视图的查询逻辑。
- `table_name` 是一个或多个基本表的名称，用于构建视图。
- `condition` 是可选的，用于筛选视图中的数据行。

总之，视图是数据库中一个强大的工具，用于简化数据访问、提高数据安全性，并促进查询重用和数据转换。





# 什么是`rerad view`

"Read view" 是 MySQL 数据库中与事务隔离级别相关的概念之一，用于确保并发事务在读取数据时能够看到一致的数据快照。在了解 "read view" 之前，让我们首先回顾一下数据库事务隔离级别。

数据库事务隔离级别定义了不同事务之间的可见性规则。MySQL 支持多种事务隔离级别，包括：

1. **READ UNCOMMITTED**：允许一个事务读取其他事务尚未提交的数据变更，可能导致脏读、不可重复读和幻读等问题。

2. **READ COMMITTED**：保证一个事务只能读取已经提交的数据，可以避免脏读，但仍然可能遇到不可重复读和幻读。

3. **REPEATABLE READ**：确保一个事务在其生命周期内看到的数据快照保持一致，避免了不可重复读，但仍然可能遇到幻读。

4. **SERIALIZABLE**：提供最高级别的隔离，确保事务之间的完全隔离，包括避免脏读、不可重复读和幻读。

"Read view" 主要在 `REPEATABLE READ` 和 `SERIALIZABLE` 事务隔离级别中起作用。

在这两个隔离级别中，当事务启动时，MySQL 会为该事务创建一个 "read view"，该视图包含了事务启动时已经存在的数据快照。这个 "read view" 将决定事务在随后的查询中可以看到哪些数据。

每个事务的 "read view" 包括以下信息：

1. **系统版本号（system version）**：表示数据库中的全局事务版本。这个版本号在每个事务启动时都会被记录下来。

2. **已提交事务列表（list of committed transactions）**：包括已经提交的事务的 ID，这些事务对于当前事务是可见的。

3. **已删除的事务列表（list of deleted transactions）**：包括已经删除的事务的 ID，这些事务对于当前事务是不可见的。

通过 "read view"，MySQL 能够在事务执行查询时检查这些信息，以确定事务可以看到哪些数据，从而实现了隔离级别的要求。

总之，"read view" 是 MySQL 数据库中用于支持 `REPEATABLE READ` 和 `SERIALIZABLE` 事务隔离级别的机制，它确保了事务在读取数据时看到一致的数据快照，以维护隔离性和数据一致性。这对于需要高度数据一致性的应用程序非常重要。





[事务隔离级别是怎么实现的？ | 小林coding (xiaolincoding.com)](https://xiaolincoding.com/mysql/transaction/mvcc.html#read-view-在-mvcc-里如何工作的)









# `read view` 和 视图的关系

"Read view" 和前面提到的 "视图" 是两个不同的概念，它们在数据库中的作用和用途也不同。以下是它们之间的关系和区别：

1. **Read View**：
   - Read view 是 MySQL 数据库中用于支持事务隔离级别的概念，通常与 `REPEATABLE READ` 和 `SERIALIZABLE` 事务隔离级别相关。
   - Read view 是一个虚拟的数据快照，用于确定在当前事务中可以看到哪些数据。它由系统版本号、已提交事务列表和已删除事务列表组成。
   - Read view 主要用于确保事务在并发执行时能够看到一致的数据状态，以维护隔离性和数据一致性。
   - Read view 是数据库内部的概念，通常不需要用户直接操作或定义。

2. **视图**：
   - 视图是一个用户定义的虚拟表，它是根据一个或多个基本表（或其他视图）的查询结果生成的结果集。
   - 视图的主要作用是为用户提供一个简化、抽象的数据访问接口，隐藏了底层表的复杂性。
   - 视图可以用于数据安全性、查询重用、数据转换和格式化等目的。
   - 视图通常由用户定义和管理，您可以使用 SQL 语句来创建、修改和删除视图。

总结而言，"Read view" 是数据库管理系统内部用于实现事务隔离级别的机制，而 "视图" 是用户定义的虚拟表，用于简化数据访问和操作。它们在数据库中的角色和用途是不同的，但都在一定程度上与数据访问和查询有关。





# 日志

`undo log` 、 `redo log` 、`bin log` 

都是存储在磁盘上的

`redo log` 用于**保存脏页的信息，容量有限（因为脏页不会无限多）**---持久性

`undo log` 用于保留记录的不同版本，事务提交前，每执行一个操作都会生成，在一定情况下会删除---原子性

`bin log` 记录了所有操作，用于**主从库备份**，没有大小限制





修改记录后，

​		会记录相应redo log（磁盘上）

​		会在合适的机会刷盘（写在磁盘上）



> MySQL的redo log一般用不到是吗?

>其实，redo log 在 MySQL 中是非常重要的组成部分之一。它记录了数据库引擎对数据进行修改或者添加的操作，以确保数据库的持久性和数据完整性。虽然大部分时间下，redo log 并不直接被使用，但在数据库发生异常情况时（比如系统崩溃或者意外断电），redo log 的作用就显现出来了。它能够帮助数据库进行恢复，确保所有已经提交的事务都能被正确地应用到数据库中，避免数据丢失或者损坏。因此，虽然平时不太关注 redo log，但它对于数据库的稳定性和数据完整性至关重要。





为了减少IO次数，可以设置 redo log 与 bin log 的刷盘策略

redo log ：

​		redo log buffer、page cache、磁盘

bin log ：

​		bin cache、page cache、磁盘

可以设置让redo log、bin log在提交多个事务后再进行刷盘：

​		redo log 			更改innodb_flush_log_at_trx_commit       （无论取何值，后台线程每间隔1秒进行一次刷盘）

​						设为0：每次事务提交只进行buffer的更改

​						设为2：每次事务提交进行buffer、page cache的更改

​						设为1：每次事务提交都进行刷盘

​		bin log 				更改sync_binlog

​					设为0：每次事务提交只进行page cache的更改（只进行write），操作决定何时进行fsync（刷盘）

​					 设为 n >1：每n次事务提交进行刷盘

​					 设为1：每次事务提交都进行刷盘

对于双1策略：

​					每次事务提交都有两次的IO操作

​					可以针对两阶段提交，将其优化为组提交

两阶段提交：

​					为了保证redo log 与 bin log 的数据一致性（从而保证主库、从库的数据一致性）

​					1、prepare阶段：将XID写入redo log并设为prepare，并刷盘

​					2、commit阶段：将XID写入bin log并刷盘，然后调用Innodb 接口将redo log 设为commit

​		改进策略：

​					引入组提交

​					将两阶段提交改为三个阶段：flush、sync、commit

​							flush：将多组事务的redo log进行prepare、bin log 进行 write

​							sync：将所有进行了flush的多组事务作为一组，进行bin log 的 fsync （即bin log的刷盘）

​							commit：将一起进行了sync的一组事务的redo log设为commit（设为commit，然后写入磁盘）

​		注：5.6及之前的版本不支持redo log 的组提交









## 物理日志 和 逻辑日志

在MySQL中，物理日志和逻辑日志是两种不同类型的日志，用于记录和维护数据库的一致性和操作。

**物理日志（Physical Logs）**：

1. **作用**：物理日志用于**记录数据库中的物理操作**，例如磁盘上的数据页的读写、事务的提交和回滚等。
2. **内容**：物理日志包含了对数据库物理结构的更改，如数据页的修改、索引的更新以及事务控制信息等。
3. **优点**：物理日志非常高效，因为它记录了底层存储引擎的操作，可以用于快速的数据库恢复和复制。
4. **示例**：MySQL中的二进制日志（Binary Logs）是物理日志的例子，用于记录底层存储引擎的操作，以支持数据备份和复制。

**逻辑日志（Logical Logs）**：

1. **作用**：逻辑日志用于**记录数据库中的逻辑操作**，例如SQL查询和数据的逻辑变化，通常与数据的高层逻辑相关。
2. **内容**：逻辑日志包含了执行的SQL语句和它们对数据库的影响，但不包括底层存储引擎的物理细节。
3. **优点**：逻辑日志更易于阅读和理解，因为它记录了数据库操作的高层逻辑，适用于逻辑复制、数据迁移和查询重放等任务。
4. **示例**：MySQL中的慢查询日志（Slow Query Log）是逻辑日志的一种，记录了执行时间较长的SQL查询，以帮助性能优化。

总结来说，物理日志和逻辑日志都是MySQL中用于记录和维护数据库一致性和操作的重要日志类型。物理日志关注底层存储引擎的操作，用于支持数据恢复和复制。逻辑日志关注高层逻辑操作，用于分析性能、执行查询重放和数据迁移等任务。数据库管理系统通常同时使用这两种类型的日志来满足不同的需求。



## `redo log`

Redo log（重做日志）是关系型数据库管理系统中的一种关键组件，用于确保数据库的持久性（durability）和故障恢复。它主要用于记录事务对数据库进行的修改操作，以便在系统故障或崩溃后，恢复到事务提交之前的状态。

下面是有关 Redo log 的详细介绍：

1. **作用**：
   - **Redo log 记录了在数据库上执行的事务的修改操作，如插入、更新、删除等。**
   - 它的主要作用是在数据库系统崩溃或故障时，通过重新执行 Redo log 中的操作来确保事务的持久性。这确保了数据的一致性，即使在不可预测的故障情况下也能够恢复到一致的状态。

2. **结构**：
   - Redo log 通常由一个或多个物理文件组成，这些文件位于磁盘上。
   - 每个 Redo log 文件由一系列的日志记录（log record）组成，每个日志记录包含了**一个或多个事务的修改操作**。
   - Redo log 记录的内容通常包括事务的标识、修改的数据页、修改前后的数据值等信息。

3. **持久性**：
   - Redo log 的记录是**在事务进行修改操作时就写入**的，而不是等到事务提交时才写入。
   - 这确保了即使在事务提交之前数据库系统崩溃，已经记录在 Redo log 中的操作也能够在恢复过程中重新应用，从而维护事务的持久性。

4. **恢复过程**：
   - 当数据库系统发生崩溃或故障时，系统会在启动时检查 Redo log 中的记录。
   - 通过重新执行 Redo log 中未提交的操作，数据库系统可以将数据恢复到最后一个已提交事务的一致状态。
   - 这个过程通常称为 "崩溃恢复"，是数据库系统的一部分，用于确保数据的持久性和一致性。

5. **性能优化**：
   - 为了提高性能，数据库系统通常会**使用缓冲区（buffer）来缓存 Redo log 记录**，然后将其批量刷新到磁盘，而不是每次修改操作都立即写入磁盘。
   - 这种方式**减少了磁盘写入的频率**，提高了数据库系统的性能。

总之，Redo log 是数据库系统中用于保障持久性和支持故障恢复的关键组件。它记录了事务的修改操作，以便在系统崩溃时能够重新执行这些操作，从而确保数据的一致性和可靠性。这对于数据库系统的可用性和可靠性至关重要。



Redo log（重做日志）是一种物理日志，它记录了数据库中的物理更改操作，包括数据页的修改、事务的提交和回滚等。Redo log 主要用于支持数据库的持久性（durability）和故障恢复，以确保在数据库崩溃或故障时可以恢复到一致的状态。它记录的是数据库中的物理操作，而不涉及SQL语句或逻辑操作的详细信息。MySQL中的二进制日志（Binary Logs）就是一种实现了重做日志功能的物理日志。

与之相反，逻辑日志记录的是SQL查询和高层逻辑操作，用于识别性能问题、进行查询重放和支持逻辑复制等任务。示例包括慢查询日志和查询日志。逻辑日志关注的是数据库操作的逻辑层面，而不涉及底层物理细节。





## `undo log`



MySQL中的undo log（撤销日志）并不会在每次事务提交后立即删除。它们会在满足以下条件的情况下被删除：

1. **事务提交**：当一个事务成功提交时，与该事务相关的 undo log 记录将成为不再需要的历史记录。这时，MySQL 不会立即删除它们，而是标记这些 undo log 记录为可回收状态。

2. **可回收状态**：一旦 undo log 记录被标记为可回收状态，它们就有可能被后续的事务复用。这是为了支持多版本并发控制（MVCC）机制，允许其他事务在不破坏一致性的情况下读取先前版本的数据。

3. **空闲时间**：当MySQL发现系统中有足够的空闲时间，通常会在后台任务中开始清理和删除可回收的 undo log 记录。这个过程通常称为"undo log purging"。

4. **保留时间**：undo log 记录可以在系统中保留一段时间，以支持长时间运行的事务或备份操作。这个保留时间通常由配置参数 `innodb_undo_retention` 控制。

5. **空间需求**：当数据库需要更多的空间来存储新的 undo log 记录时，旧的可回收 undo log 记录可能会被删除以释放空间。

总之，undo log 记录的删除不是立即发生的，而是在数据库引擎的管理下，根据一系列策略和条件来进行的。这种机制确保了数据库的一致性、事务的持久性，并且支持多版本并发控制，但也需要适当的配置和管理，以确保不会导致undo log 过度膨胀或空间不足的问题。配置参数和清理策略可以根据数据库的需求进行调整。





Undo log（撤销日志）是关系型数据库管理系统中的另一个关键组件，用于支持事务的**回滚操作**和**多版本并发控制**。它记录了事务对数据库所做的修改操作的逆操作，以便在需要时撤销或回滚事务的更改。

以下是有关 Undo log 的详细介绍：

1. **作用**：
   - Undo log 主要用于支持数据库事务的回滚操作，以及多版本并发控制（MVCC）。
   - 它**记录了事务对数据库中的数据所做的修改的逆操作**，以便在事务回滚时能够撤销这些修改。回滚
   - Undo log 还**允许在同一时间在数据库中存在多个版本的数据，以支持不同事务之间的并发性**。MVCC

2. **结构**：
   - Undo log 通常由一个或多个物理文件组成，这些文件位于磁盘上。
   - 每个 Undo log 记录包含了**一次事务修改的逆操作**，通常包括了修改前的数据值、事务标识和数据页等信息。
   - Undo log 记录的逆操作可以用于恢复事务之前的数据状态。

3. **回滚操作**：
   - 当事务需要回滚时，数据库系统会根据 Undo log 中的记录执行逆操作，将数据库恢复到事务开始之前的状态。需要回滚：eg：出现违法数值、违背了一致性等
   - 这意味着 Undo log 记录了事务所做的修改的逆操作，以便撤销这些修改。

4. **多版本并发控制**：
   - Undo log 还用于实现多版本并发控制（MVCC），**允许不同事务在同一时间访问数据库中的不同版本的数据**。
   - 当一个事务修改数据时，它会创建一个新的数据版本，并在 Undo log 中记录这个版本的逆操作。
   - 这使得**其他事务可以同时访问旧版本的数据，从而提高了并发性能**。

5. **性能优化**：
   - 与 Redo log 类似，数据库系统通常会**使用缓冲区来缓存 Undo log 记录**，以减少磁盘写入的频率。
   - Undo log 记录也可以**根据事务的生命周期来管理**，一旦事务提交，相应的 Undo log 记录可以被回收。

总之，Undo log 是数据库系统中用于支持事务回滚操作和多版本并发控制的关键组件。它记录了事务对数据库的修改的逆操作，以便在需要时能够回滚事务的更改，同时也支持多版本的数据并发访问，提高了数据库系统的性能和并发性。这对于保障事务的一致性和数据库的可靠性非常重要。



Undo log（撤销日志）通常被视为物理日志，因为它记录了数据库中的物理更改操作，但它也有一些逻辑层面的特征。

具体来说，Undo log 记录了事务对数据库中的数据所做的修改操作的逆操作，以便在需要时撤销或回滚事务的更改。它包含了修改前的数据值、事务标识和数据页等信息，这些信息用于在事务回滚时将数据恢复到事务开始之前的状态。因此，从物理角度来看，Undo log 记录了数据的物理变化。

然而，Undo log 也有逻辑层面的特征，因为它是用于事务管理的一部分，而不是记录SQL查询或高层逻辑操作的详细信息。它不像二进制日志（Binary Logs）那样记录SQL语句的文本，而是关注于记录数据的物理修改和事务控制信息。所以，虽然 Undo log 在某种程度上是物理日志，但它也具有一些逻辑方面的含义。

总的来说，Undo log 是更接近物理日志的一种类型，但它主要用于支持事务管理和回滚操作，而不是记录高层逻辑操作或SQL语句的详细信息。







# 锁

## 什么是锁

在数据库管理系统中，锁（Lock）是一种用于管理并发访问共享资源的机制。锁可以控制多个事务或线程对资源的访问，以确保数据的一致性和完整性。锁通常用于以下情况：

1. **并发控制**：当多个事务或线程同时访问数据库或共享资源时，锁用于协调它们的访问，以避免数据冲突和不一致。

2. **事务隔离**：数据库事务需要在一个隔离的环境中执行，锁可以确保不同事务之间的操作互不干扰。

3. **资源保护**：锁可以用于保护关键资源，例如数据行、表、页或数据库对象，以防止未经授权的访问或修改。

在数据库中，锁通常分为两种主要类型：

1. **共享锁（Shared Lock）**：也称为读锁（Read Lock）。多个事务可以同时持有共享锁，并且这些事务可以并发地读取数据，但不能进行写操作。共享锁适用于多个事务需要同时读取数据而不会相互干扰的场景。

2. **排他锁（Exclusive Lock）**：也称为写锁（Write Lock）。只有一个事务可以持有排他锁，它允许事务进行写操作，但阻止其他事务同时持有共享锁或排他锁。排他锁用于确保在写入数据时不会发生并发冲突。

在不同的数据库管理系统中，锁的实现方式和语法可能会有所不同，而且锁的粒度可以从非常细粒度的数据行锁到较粗粒度的表锁，具体取决于数据库的设计和配置。

总之，锁是数据库管理系统中用于管理并发访问的重要机制，它可以确保数据的一致性和完整性，并协调多个事务或线程之间的操作，以避免冲突和数据损坏。不同类型的锁适用于不同的访问需求和隔离级别。



## `S` 锁 与 `X` 锁

S锁（Shared Lock）和X锁（Exclusive Lock）是数据库管理系统中常见的两种锁类型，用于控制并发访问共享资源的方式不同。以下是对S锁和X锁的详细介绍：

**S锁（Shared Lock）**：

1. **作用**：
   - S锁是共享锁，也称为读锁。
   - 多个事务可以同时持有S锁，允许并发读取共享资源，但不允许写入。
   - S锁通常用于读取操作，允许多个事务同时读取相同的数据而不互相干扰。

2. **特点**：
   - 共享性：多个事务可以同时持有S锁，以便并发地读取数据。
   - 不互斥：S锁之间不互相排斥，多个事务可以同时持有S锁，不会相互阻塞。
   - 阻止写操作：S锁会阻止其他事务获得X锁，从而防止写操作的并发冲突。

3. **示例**：
   - 多个用户可以同时读取同一数据表的内容，以提高并发读取性能。

**X锁（Exclusive Lock）**：

1. **作用**：
   - X锁是排他锁，也称为写锁。
   - 一次只能有一个事务持有X锁，允许进行写操作，但阻止其他事务的读取和写入。
   - X锁通常用于修改数据，确保写操作的完整性。

2. **特点**：
   - 互斥性：X锁是互斥的，一次只能有一个事务持有X锁，其他事务无法同时持有X锁或S锁。
   - 阻塞读写操作：持有X锁的事务会阻止其他事务同时读取和写入相同的资源。
   - 写操作：X锁通常用于执行插入、更新和删除等写操作。

3. **示例**：
   - 当一个事务正在修改某个数据行时，其他事务无法同时读取或修改同一数据行，以确保数据完整性。

总结来说，S锁用于允许多个事务并发地读取相同的资源，但不允许写入操作。X锁用于排他性地控制对资源的访问，一次只允许一个事务持有，并且通常用于写入操作。这两种锁类型在数据库系统中用于管理并发访问，确保数据的一致性和完整性。 S锁和X锁通常一起使用，以实现事务的隔离和并发性。



## 设置 `S`锁 的意义

对于S锁（Shared Lock），其主要意义在于允许多个事务并发地读取相同的资源，而不会相互干扰。虽然多个事务可以同时持有S锁，但这并不是为了阻止其他事务持有S锁，而是为了支持并发读取操作，提高数据库的性能和响应速度。

以下是设置S锁的主要意义：

1. **并发性**：S锁允许多个事务同时读取相同的资源，这对于具有高并发读取需求的数据库应用程序非常重要。多个事务可以并发地执行读取操作，而不会互相阻塞，从而提高了数据库的并发性和性能。

2. **读取一致性**：S锁确保了读取操作的一致性。即使有其他事务正在读取同一资源，也不会出现数据不一致或脏读的情况。读取操作在获得S锁后可以读取到已提交的数据，而不会读取到正在进行中的写操作所修改的数据。

3. **防止写操作冲突**：虽然S锁允许多个事务并发读取，但它与X锁（排他锁，用于写操作）是互斥的。这意味着当一个事务持有X锁时，其他事务无法获得相同资源的S锁，从而防止了写操作之间的冲突。

4. **性能优化**：通过允许多个事务并发读取，S锁有助于提高数据库的读取性能，减少了读取操作的等待时间。

总的来说，S锁的意义在于支持多个事务并发地读取共享资源，同时保持数据的一致性和完整性。它是数据库系统中实现读取操作并发性的关键机制之一，对于高并发读取需求的应用程序非常重要。同时，S锁与X锁之间的互斥性确保了写操作的数据一致性。



## 会产生加锁行为的操作

在数据库中，有多种操作可以导致锁的加锁行为，这些操作通常与事务有关。以下是一些常见的操作，它们可能会导致锁的加锁：

1. **SELECT语句**：
   - 在某些情况下，SELECT语句可能会在读取数据时获取共享锁（S锁），以确保读取的数据在操作期间不被其他事务修改。

2. **INSERT、UPDATE和DELETE语句**：
   - INSERT、UPDATE和DELETE语句通常会在执行写操作时获取排他锁（X锁），以确保在事务完成之前不会有其他事务同时对相同的数据进行写操作。

3. **事务的BEGIN和COMMIT**：
   - 在事务开始时（BEGIN）和提交时（COMMIT），通常会获取和释放一些锁，以确保事务的一致性。

4. **数据表级别的锁**：
   - 有些数据库支持在整个数据表上获取锁，以防止其他事务访问整个表。这种锁称为表级别的锁，通常是排他锁。

5. **索引级别的锁**：
   - 在某些情况下，数据库系统会在索引上获取锁，以防止其他事务修改与索引相关的数据。这种锁通常是排他锁。

6. **死锁检测**：
   - 当数据库系统检测到潜在的死锁情况时，它可能会自动添加锁以解决死锁。这些锁可能是共享锁或排他锁，具体取决于数据库系统的实现。

需要注意的是，不同的数据库管理系统（如MySQL、Oracle、SQL Server等）可能会在不同的情况下加锁，并且加锁的行为可能会受到数据库的配置和隔离级别的影响。锁的使用是为了维护数据的一致性和完整性，但不正确的锁定行为可能会导致性能问题和死锁情况。因此，在设计和编写数据库应用程序时，需要谨慎考虑锁的使用和释放，以确保数据的正确性和性能。



## 读锁是共享锁，写锁是独占锁

```
表t1使用InnoDB引擎，以下哪个场景会导致语句s1:selectfrom t1 limit 1被堵住? 
A 另一个线程在Q1执行之前，执行了alter tablet1 addindex(f1)，当前处于“拷贝数据到临时表”阶段
B 另一个线程在Q1执行之前，执行了 delete from t1，且未执行完成 
C 另一个线程在Q1 执行之前，执行了 lock table t1 write，并执行完成 
D 另一个线程在Q1执行之前，执行了截断表t1，当前处于等待元数据锁定阶段
```

A 另一个线程在Q1执行之前，执行了alter table t1 add index (f1)，当前处于“拷贝数据到临时表”阶段，这个操作会导致语句s1: select from t1 limit 1 被堵住。

在InnoDB引擎下，**添加索引操作会导致表的重建或者数据的拷贝到临时表**，**这个过程可能会锁住表或者行**，从而影响其他查询语句的执行。在这种情况下，语句s1可能需要等待alter操作完成才能继续执行。其他选项中的操作也可能导致锁定，但不一定会导致语句s1被堵住。

让我们分析一下其他选项：

B 另一个线程在Q1执行之前，执行了 delete from t1，且未执行完成：删除操作可能会导致行级锁，但是如果是一个简单的删除操作，不会导致语句s1被堵住。语句s1是一个简单的查询，通常不会被一个删除操作所阻塞。

C 另一个线程在Q1执行之前，执行了 lock table t1 write，并执行完成：锁表操作通常会导致其他线程无法同时对表进行写操作，但语句s1是一个简单的查询语句，通常不需要对表进行写锁。因此，这个选项不会导致语句s1被堵住。

D 另一个线程在Q1执行之前，执行了截断表t1，当前处于等待元数据锁定阶段：截断表操作可能会锁定表的元数据，但通常不会锁定表中的行。语句s1是一个简单的查询语句，不需要锁定表的元数据，因此这个选项也不太可能导致语句s1被堵住。

总的来说，虽然这些操作可能会在表上引入锁定，但它们通常不会导致简单的查询语句s1被堵住。只有选项A中的"alter table t1 add index"操作通常会导致查询语句被堵住，因为在添加索引时可能需要对表进行重建或拷贝数据到临时表，这可能会影响其他查询的执行。因此，选项A是最有可能导致语句s1被堵住的情况。





# 索引

使用**主键查询**（聚簇索引）：

​			存储引擎找到主键符合条件的数据，将数据返回给执行器，执行器判断，交付给客户端/丢弃

​			**主键索引查询**，读取一次数据（节点）

​			执行器调用read_first_record，存储引擎根据主键查询聚簇索引，直接找到记录，将记录返回给执行器，执行器进行判断，符合要求就交付给客户端；接着执行器（while）调用read_record，存储引擎根据主键继续查找聚簇索引，找不到了，返回-1给执行器，执行器返回-1给客户端并跳出while，客户端打印收到的记录



使用**二级索引查询**：

​			**查询的是id**：**索引覆盖**，存储引擎找到符合条件的二级索引后，返回id给执行器，不用再回表。（因为二级索引的 B+ 树的叶子节点的数据存储的是主键值）

​			查询的不是id：需要**回表**，执行器调用read_first_record，存储引擎通过二级索引查找到符合条件的主键，再用该主键去聚簇索引进行查询，在聚簇索引找到记录，返回记录给执行器，执行器判断，返回客户端/丢弃；接着执行器while调用read_record，存储引擎再次在二级索引中查找符合条件的索引，找到主键并回表，返回给执行器，执行器进行判断；执行器再次while……直到查找了全部的二级索引，存储引擎直接返回-1给执行器，执行器返回-1给客户端并跳出while，客户端打印收到的全部记录。需要进行回表，需要查两个B+树。



**没有使用任何索引**（where筛选的条件不是主键索引/二级索引）：

​			进行**全表扫描**，执行器先调用read_first_record，存储引擎返回表中的第一条记录给执行器，执行器判断，返回给客户端/丢弃；接着执行器调用read_record，存储引擎返回下一条记录给执行器，执行器判断，返回给客户端/丢弃；接着执行器再次调用read_record……直到读取了全部的数据，存储引擎返回读取结束的标识给执行器，执行器跳出while循环并给客户端发结束信息，客户端收到结束信息后，再将所有收到的记录进行显示



**联合索引**：

​			若有两个字段建立了联合索引（age、reward），查询时使用的是age > 20,reward = 100000，因为有>，所以reward不能再使用联合索引（age可以使用联合索引）（范围查询>  <的字段可以使用联合索引，范围查询，后面的字段，无法使用联合索引）

​			但因为age、reward都包含着联合索引里，可以进行**索引下推**

​			若age、reward没有建立联合索引（age有建立二级索引），则无法进行索引下推（但也不用全表扫描），此时的查询流程：

​						执行器将age>20的条件发送给存储引擎（第一次时调用read_first_record，之后调用read_record），存储引擎根据age的二级索引，找到满足age>20的记录的主键（id），再根据该主键去聚簇索引查找到该记录（回表），将该记录整个返回给执行器，执行器进行判断（发送个客户端/丢弃）；接着由于执行器的while循环调用，存储引擎继续查找下一个age索引，找到id，根据id进行回表在聚簇索引找到该数据，将数据整个返回给执行器，执行器判断；直到所有的age都被检索完，存储引擎直接返回-1给执行器，执行器返回-1给客户端并跳出while，客户端将收到的所有记录输出

​			若age、reward有建立联合索引，虽然因为有 > 不能使用联合索引，但可以进行**索引下推**：

​						执行器将age>20发送给存储引擎，存储引擎根据联合索引（二级索引）找到age>20的记录，然后直接判断reward是否满足要求，如果是，则获取该记录的主键，根据该主键进行回表，在聚簇索引中找到该记录，将该记录返回给执行器，执行器进行判断（返回给客户端/丢弃），如果reward不满足要求，则存储引擎跳过该二级索引，不进行回表（也不会返回给执行器）；接着（如果有返回，执行器while循环调用read_record）查找下一个age满足要求的联合索引；直到遍历完age与reward的联合索引，存储引擎直接返回-1给执行器，执行器返回-1给客户端并跳出while，客户端将收到的记录输出





## 聚簇索引/主键索引

**任何表只有一个聚簇索引**

创建方式：

```
CREATE TABLE table_name  (
  ....
  PRIMARY KEY (index_column_1) USING BTREE
);
```

聚簇索引（Clustered Index）是一种特殊的索引类型，它在某些数据库系统中存在，例如Microsoft SQL Server和InnoDB存储引擎的MySQL。与传统的非聚簇索引（如B-tree索引）不同，聚簇索引的叶子节点存储的是实际数据行，而不是指向数据行的指针。这是聚簇索引的主要特点之一。

具体来说，**聚簇索引的叶子节点存储的是以下内容：**

1. **索引键值**：每个聚簇索引的叶子节点包含索引列的键值。这些键值按照索引的排序顺序排列。

2. **实际数据行（而不是指向实际数据的指针）**：与索引键值关联的数据行（记录）被存储在聚簇索引的叶子节点中。这意味着聚簇索引的叶子节点直接包含了表中的实际数据，而不是指向数据行的指针。

由于聚簇索引的叶子节点存储了实际数据行，因此它具有一些特定的性质和优势：

- **聚簇索引决定了数据存储的物理顺序**：数据表的物理存储顺序与聚簇索引的顺序一致，这可以提高范围查询的性能，因为相关的数据行通常会在物理上相邻存储。

- **减少磁盘I/O操作**：由于数据行直接存储在聚簇索引的叶子节点中，查询可以更快地定位和检索数据，从而减少磁盘I/O操作，提高查询性能。

- **适用于覆盖索引**：如果查询可以使用聚簇索引覆盖，即查询条件和所需输出列都在聚簇索引中，那么查询可以非常高效地执行，因为不需要访问实际的数据行。

需要注意的是，并不是所有数据库系统都支持聚簇索引，而且它在不同数据库系统中的实现方式可能会有所不同。因此，要了解聚簇索引的详细信息，需要查看特定数据库管理系统的文档和实现。



注意：

**MyISAM存储引擎中，索引的节点存储的是指向数据行的指针，而不是实际数据行。**

**MyISAM的索引文件与数据文件是分开的。**

**MyISAM 存储引擎不支持聚簇索引。**聚簇索引是一种特殊的索引类型，它将数据行存储在索引的叶子节点中，而不是在表的数据区域中。这使得聚簇索引在某些情况下能够提供更好的性能，尤其是对于范围查询和覆盖索引的支持。

MyISAM 存储引擎在设计上不包括聚簇索引的支持。**在 MyISAM 中，数据行存储在表的数据文件中，而索引文件仅包含索引键值和指向数据行的指针。**这意味着 MyISAM 表的索引结构相对简单，不包含聚簇索引。

如果您需要使用聚簇索引以及事务支持等高级功能，通常应该考虑使用 InnoDB 存储引擎。InnoDB 支持聚簇索引，以及其他高级功能，如事务处理、行级锁和外键约束。但要注意，InnoDB 的性能特征和配置选项与 MyISAM 有所不同，因此在选择存储引擎时需要考虑具体的应用需求。





## 二级索引/辅助索引

二级索引（Secondary Index）的叶子节点存储的是指向实际数据行的指针（或者称为行标识符）。二级索引是一种数据库索引，用于加速非主键列的查询操作。它不像聚簇索引那样在叶子节点中存储实际数据行，而是存储了用于定位数据行的引用信息。

具体来说，**二级索引的叶子节点包含以下内容：**

1. **索引键值**：每个叶子节点包含索引列的键值。这些键值按照索引的排序顺序排列。

2. **指向实际数据行的指针**：叶子节点中包含了指向对应数据行的指针（或者称为行标识符）。这些指针告诉数据库系统在哪里可以找到与索引键值匹配的数据行。指针可以是磁盘上的物理地址或行号。

由于二级索引不存储实际数据行，而只存储指向数据行的指针，因此它的叶子节点通常比聚簇索引的叶子节点小得多。这可以节省磁盘空间，并使得在查询时可以更快地定位到实际数据行。

二级索引在数据库中用于支持多种查询操作，包括等值查找、范围查找、排序等。当查询涉及非主键列时，数据库系统可以使用相应的二级索引来快速定位到匹配的数据行。

需要注意的是，不同的数据库管理系统可能在二级索引的实现细节上有所不同，但上述内容描述了一般情况下二级索引的叶子节点所存储的内容。





## 联合索引

**联合索引中包含多个列，第一个列是有序的**

即

什么是联合索引：

联合索引（Composite Index）是数据库中的一种索引类型，它**由多个列组合而成，用于加速包含这些列的查询操作**。联合索引也被称为复合索引或组合索引。与单列索引不同，联合索引可以在多个列上建立，以提高多条件查询的性能。

以下是关于联合索引的主要特点和解释：

1. **组合多列**：联合索引由多个列组合而成，这意味着它覆盖了多个列的数据，而不仅仅是单一列。每个列都按照特定的顺序加入索引。

2. **查询优化**：联合索引的主要目的是**加速包含了索引中的列的查询操作**。**当一个查询涉及到了联合索引中的列，并且这些列的组合出现在索引中时**，查询可以更快地定位到匹配的数据行。（通常需要优化器优化索引顺序）

3. **适用于多条件查询**：联合索引特别适用于多条件查询，其中多个列的值都用于过滤数据。通过在这些列上建立联合索引，可以避免全表扫描，提高查询性能。

4. **索引键的顺序**：联合索引中列的顺序很重要。查询中使用的列应该与联合索引中列的顺序相匹配，以获得最佳的性能提升。例如，**如果一个联合索引包含了`(列A, 列B)`，那么查询中首先使用`列A`的条件，然后使用`列B`的条件，可以充分利用该索引。**  **即联合索引中第一个列是有顺序的。**

5. **示例**：假设有一个包含订单信息的表格，包括订单号、订单日期和客户姓名。如果您需要查询所有在特定日期下的订单号，而且在订单号上有一个索引，那么该查询可以通过索引覆盖进行，只需访问索引而不必读取实际的数据行。

需要注意的是，虽然联合索引可以显著提高多条件查询的性能，但它也可能会增加插入、更新和删除操作的开销，因为数据库系统需要维护多个列的索引。因此，在设计数据库表结构时，需要根据查询需求和性能要求来决定是否使用联合索引，并仔细考虑索引列的顺序。



**联合索引节点存储的内容：**

在一个联合索引（Composite Index）中，每个索引节点通常存储以下内容：

1. **索引键值**：每个索引节点包含一个或多个列的索引键值。这些键值是索引的关键部分，用于排序和定位数据行。联合索引的每个节点按照列的顺序存储键值。

2. **指向数据行的指针**：索引节点通常包含指向实际数据行的指针，这些指针告诉数据库系统在哪里可以找到与索引键值匹配的数据。这可以是磁盘上的物理地址或行号，用于直接访问数据。

3. **额外的元数据**：索引节点可能包含一些额外的元数据，如时间戳、版本号或其他与索引相关的信息。这些信息可以用于管理索引的维护和优化。

每个索引节点都按照索引键值的顺序存储，这使得索引具有有序性，有助于快速地定位到匹配的数据行。索引节点通常是树结构的一部分，具有父节点、子节点和叶子节点等层次结构。这种结构使得在不同层次上的索引节点存储不同的信息，以支持高效的索引查询操作。

需要注意的是，具体的索引实现可能因数据库管理系统的不同而有所不同，但上述内容描述了一般情况下联合索引节点中通常存储的信息。



## 不同索引的节点比较

**非叶子节点：**

1. **索引键值**：每个非叶子节点包含索引列的键值。这些键值按照索引的排序顺序排列。

2. **指向下一级非叶子节点或叶子节点的指针**：非叶子节点中通常包含指向下一级非叶子节点或叶子节点的指针。这些指针帮助数据库系统在索引树中导航，以最终定位到包含所需数据行的叶子节点。

不管是聚簇索引、二级索引、联合索引，这三者的非叶子节点存放的内容都一样



**叶子节点：**

1. **聚簇索引**存放：**索引键值**、**实际数据行（而不是指向实际数据的指针）**
2. **二级索引**存放：**索引键值**、**指向实际数据行的指针**、**主键**
3. **联合索引**存放：**索引键值**、**指向实际数据行的指针**、**主键**







# 数据的存储

## 变长字段的长度怎么知道？

变长字段长度列表

每个变长字段列，都有一个对应的变长字段长度列表

若某变长字段列的允许最大长度小于255字节，则其对应的变长字段长度列为1字节

若某变长字段列的允许最大长度大于255字节，则其对应的变长字段长度列为2字节



变长字段列表在记录的额外信息中



 每个列都有自己的变长字段长度列



## `NULL`值怎么知道？

`NULL`值列表

若允许为NULL值的列小于8个，则NULL值列表大小为1字节，

若允许为NULL值的列大于8个，小于16个，则NULL值列表为2字节

以此类推



多个列公用NULL值列表的1字节
