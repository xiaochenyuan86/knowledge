[toc]



# 双指针法核心思想

- 某节点要被至少一个指针指向，才能被找到

- 若想要更改某节点的next指针，则创建一个临时指针temp保存该next指针，防止找不到next指针指向的节点

- 若某节点被两个指针指向，则更改指向该节点的某一指针

```C++
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
    //暴力解法，双指针法pre、cur  temp
    ListNode* cur = head;               //cur是即将被改变next指向的节点，要改变cur->next的指向，所以要引入一个temp来指向cur->next节点，防止后面找不到该节点
    ListNode* pre = nullptr;
    while (cur){
        ListNode* temp = cur->next;
        cur->next = pre;                //此操作前有两个指针指向cur->next、temp，所以更改cur->next
        pre = cur;                      //此操作前只有cur指向该节点，而pre、cur->next指向同一节点所以先更改pre指向，再更改cur
        cur = temp;                     //此操作前cur、pre指向同一节点，更改cur
    }
    return pre;                         //循环结束后pre指向新的头节点，cur、temp为空
    
    }
```



# 递归算法

不同的递归算法时间复杂度可能不同，不能一概而论



想象已经把子模块处理好了，只需再处理当前模块，就全部处理完成





## 两种不同的递归算法：



主模块返回与子模块的返回不同：

[24. 两两交换链表中的节点 - 力扣（LeetCode）](https://leetcode.cn/problems/swap-nodes-in-pairs/solutions/2356870/di-gui-shi-xian-lian-biao-liang-liang-ji-ps7u/)

主模块的返回与子模块的返回相同：

[206. 反转链表 - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-linked-list/solutions/2356746/di-gui-fa-shi-xian-by-achen-w-0ejm/)





# 哈希表

有三种实现方法：

## 数组

例如将26个字母映射到数组中

## set

![image-20230811165945203](assets/image-20230811165945203.png)

std::unordered_set底层实现为哈希表，std::set 和std::multiset 的底层实现是红黑树，红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。

用unordered_map比较多

unordered_map是无序的，会以输入的顺序存储元素，而不会将所存储的元素自己给排序。



### unordered_set的erase操作

The `erase` function for the `std::unordered_map` container in C++ is used to remove elements from the unordered map. It takes either an iterator pointing to the element to be removed or a key that corresponds to the element you want to erase. Here's how you can use the `erase` function with `std::unordered_map`:

1. Using an Iterator:
```cpp
std::unordered_map<KeyType, ValueType> myMap;
// ... populate the map ...

auto iter = myMap.find(key);  // Find the iterator to the element with the specified key
if (iter != myMap.end()) {
    myMap.erase(iter);  // Erase the element pointed to by the iterator
}
```

2. Using a Key:
```cpp
std::unordered_map<KeyType, ValueType> myMap;
// ... populate the map ...

myMap.erase(key);  // Erase the element with the specified key
```

It's important to note that if the specified key is not found in the map, the `erase` function does nothing. It doesn't throw an exception or produce an error in this case.

The `erase` function returns the number of elements removed (which will be either 0 or 1) because an unordered map can have at most one element with a given key.

Remember that erasing elements from an unordered map may trigger rehashing, which could affect the performance of the container.



## map

![image-20230811170005846](assets/image-20230811170005846.png)







# <<  左移操作

位左移操作（`<<`）是 C++ 中的一种位操作，它将一个数的二进制表示向左移动指定的位数。这种操作会在数值上产生乘法的效果，即**将数值扩大为原来的2的幂次倍**。让我们详细介绍一下位左移操作的工作原理和用途。

### 工作原理

对于一个整数 `x`，将其左移 `n` 位，即 `x << n`，会将 `x` 的二进制表示中的所有位向左移动 `n` 位，右侧用零填充。

 **`x << n`**

**左移操作的效果是将 `x` 的值乘以 `2^n`。**

例如，假设 `x` 的二进制表示为 `1010`，即十进制的 10，如果将其左移 2 位，即 `x << 2`，得到的结果是 `101000`，即十进制的 40。

### 应用场景

1. **计算 2 的幂次方：** 位左移操作在计算 2 的幂次方时非常有用。如果要计算 `2^n`，只需将 1 左移 `n` 位。例如， `1 << 3` 等于 8，表示 2 的 3 次方。

2. **位运算和位掩码：** 位左移操作在进行位运算和位掩码时很常见。通过将不同的位左移，可以创建掩码来设置或清除特定的位。这对于在二进制表示中操作标志位非常有用。

3. **性能优化：** 在某些情况下，位左移操作可以用于取代乘法操作，从而提高性能。因为位操作在硬件层面更加高效，所以在某些情况下可以优化代码的执行速度。

### 示例代码

下面是一个示例代码，演示了位左移操作的用法：

```cpp
#include <iostream>

int main() {
    int x = 10;   // Binary: 1010
    int n = 2;

    int result = x << n;  // Left shift x by n bits

    std::cout << x << " << " << n << " = " << result << std::endl;

    return 0;
}
```

输出将是：

```
10 << 2 = 40
```

总之，位左移操作是 C++ 中的一项基本操作，可以用于计算 2 的幂次方、位运算和性能优化等方面。通过理解它的工作原理和应用场景，您可以更好地在代码中利用这一操作。****

## << 计算2的次幂

`1 << n` 和 `2 << n` 表示左移操作，但它们的结果是不同的。

1. **`1 << n`**: 这个操作表示将二进制数 1 左移 n 位。因为二进制数 1 在二进制表示中只有最低位为 1，其他位都是 0，所以左移操作后，只有最低位变为 0，其他位仍然是 0。

   例如，`1 << 3` 表示将二进制数 001 左移 3 位，结果为 1000，即十进制的 8。

2. **`2 << n`**: 这个操作表示将二进制数 2 左移 n 位。因为二进制数 2 在二进制表示中是 10，即最低位是 0，倒数第二位是 1，其他位都是 0。左移操作后，所有位都向左移动，右侧用 0 填充。

   例如，`2 << 3` 表示将二进制数 00010 左移 3 位，结果为 10000，即十进制的 16。

所以，`1 << n` 表示计算 2 的 n 次方，而 `2 << n` 表示计算 2 的 n+1 次方。







# 回溯

组合、子集、分割

无论如何，都不能返回重复的集合

一个集合：
## 组合
### 集合中无重复元素：

不需要进行树层去重

每个元素**仅使用一次**：下一层的startIndex赋值为i + 1

可以**多次使用**：下一层的startIndex赋值为 i

同一树层每个元素永远只使用一次，操作的是同一树枝

### 集合中有重复元素:

要进行**树层去重**（以免有相同的组合）

## 树层去重方法

树层去重，就是**同一树层中不能使用数值相等的两个元素**

### 组合：

 i 从 startIndex 开始

**可以对原始数组排序**

```
if (i > startIndex && nums[i] == nums[i - 1]) continue;
```


**不可以对原始数组排序**：

用哈希表（数组、set等）进行树层去重

**根据数组元素值构建数组，而不是根s据数组下标**

```
if (usedArry[nums[i]] == 1) continue;
```



### 排列

i 从 0 开始

可以对原始数组排序

判断 usedArry[i - 1]

根据数组下标构建数组，比较usedArry[i - 1]

```
if (i > 0 && nums[i] == nums[i - 1] && usedArry[i - 1] == 0) continue;
```

要加上`usedArry[i - 1] == 0` 否则会对树枝去重

因为`usedAaary` 会树枝回溯，所以可以进行数层去重



## 子集

收集的是所有节点，不止叶子

## 分割

每一层将从startIndex 到 i进行分割，如果可行就分割，并进行下一层分割；如果不可行就i++





## 不同集合

i 从 0 开始，而不是startIndex

每一层扫描一个集合的每一个元素

需要一个index指示本层扫描的集合



## 树枝与树层

树枝去重与树层去重

**一个树枝间共享的变量：**

- 在函数外部定义变量

- 在主函数中定义（作为递归函数的参数）

一个树枝间共享变量**需要回溯**

每一个树枝都共享一个变量

**一个树层间共享的变量：**

- 在递归函数内定义（这样每一树层的递归函数都会初始化一个变量）

树层间共享的变量**不需要回溯**



## 全排列问题

每层递归的**for循环从0开始**，而不是startIndex

```
for(int i = 0; i < nums.size(); i++) {
	if (usedArray[i] == i) continue;
	usedArray[i] = 1;
	path.push_back(nums[i]);
	backtracking(nums);
	usedArray[i] = 0;
	path.pop_back();
}
```

排列问题**需要进行一个树枝之间的去重**，如果同一树枝之前用过了该元素nums[i]，则continue, i++

终止条件是将集合的全部元素都选取到path，则将该叶子插入



### 若集合有相同的元素

则全排列问题不仅需要同一**树枝之间去重**，还要进行**树层之间去重**

```
for(int i = 0; i < nums.size(); i++) {
	if (usedArray[i] == 1) continue;	 // 树枝去重
	if (i > 0 && nums[i] == nums[i - 1] && usedArray[i - 1] == 0) continue; 	// 树层去重
	
	usedArray[i] = 1;
	path.push_back(nums[i]);
	backtracking(nums);
	usedArray[i] = 0;
	path.pop_back;
}
```

`if (i > 0 && nums[i] == nums[i - 1] && usedArray[i - 1] == 0) continue;` 会对树层去重，不会对树枝去重，

一个树枝不可以两次使用同一个元素，但可以使用数值相等的两个元素

一个树层不会两次使用同一个元素，且不会使用数值相等的两个元素（防止有重复组合）



eg：1、1、2，

1大头的组合，当i == 1时已经全部选取，当i == 2时不需要再进行选取（否则会有重复组合）









# 数字、字符串转换

## 字符串转为数字

在C++中，你可以使用 `std::stoi` 函数将字符串转换为整数，使用 `std::stof` 函数将字符串转换为浮点数，以及使用 `std::stod` 函数将字符串转换为双精度浮点数。这些函数都位于 `<string>` 头文件中。

以下是将字符串转换为整数和浮点数的示例：

1. 将字符串转换为整数：

```cpp
#include <iostream>
#include <string>

int main() {
    std::string str = "12345";
    int num = std::stoi(str);

    std::cout << "String as integer: " << num << std::endl;

    return 0;
}
```

在上面的示例中，我们使用 `std::stoi` 将字符串 "12345" 转换为整数 `num`。

2. 将字符串转换为浮点数：

```cpp
#include <iostream>
#include <string>

int main() {
    std::string str = "3.14159";
    float floatingNum = std::stof(str);

    std::cout << "String as float: " << floatingNum << std::endl;

    return 0;
}
```

在这个示例中，我们使用 `std::stof` 将字符串 "3.14159" 转换为浮点数 `floatingNum`。

如果字符串无法成功转换为数字，这些函数将引发 `std::invalid_argument` 异常。因此，在使用这些函数时，最好使用 `try...catch` 块来处理异常，以确保代码的健壮性。

## 数字转为字符串

在C++中，你可以使用标准库函数 `to_string` 来将数字转换为字符串。这个函数接受一个数字作为参数，并返回该数字的字符串表示形式。以下是一个示例：

```cpp
#include <iostream>
#include <string>

int main() {
    int num = 12345;
    std::string str = std::to_string(num);

    std::cout << "Number as string: " << str << std::endl;

    return 0;
}
```

在上面的示例中，我们首先将整数 `num` 初始化为 `12345`，然后使用 `std::to_string(num)` 将其转换为字符串 `str`。最后，我们使用 `std::cout` 打印出字符串。

这是将数字转换为字符串的一种简单方法，适用于大多数情况。如果你需要更复杂的格式化，你还可以使用 `std::stringstream` 或其他字符串处理方法。





# 完全二叉树

n为总结点数，n1为有一个孩子的节点数，n2为有两个孩子的节点数，n0为叶子节点

有如下两个公式：
$$
n = n_0 + n_1 + n_2
$$

$$
n_0 = n_2 + 1
$$
公式2推导：

边数：
$$
n - 1 = 2*n_2 + 1*n_1
$$


**n1的取值：0或1**，不能取别的值









# ACM 模式

```
`cin`

读入一个数字

以空格、换行符、tab 结束；对待空格、换行是一致的，可以一直cin下去

需 include <iostream>

int num;
cin >> num;

while(cin >> a >> b) {
	cout << a + b << endl;
}
```



```
`getline`

读入一行

需 include <string>

string s;
getline(cin, s);
cout << s << endl;
```





